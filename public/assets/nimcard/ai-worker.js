var e,t,a,r,n;!function(e){e.makeCommit=(e,t,a)=>()=>{const r=e.board[t],n=r.slice(r.length-a,r.length);return{board:e.board.map(((e,r)=>e.slice(0,e.length-(r===t?a:0)))),currentPlayer:(e.currentPlayer+1)%e.players.length,players:e.players.map(((t,a)=>t.concat(a===e.currentPlayer?n:[])))}};const t=(t,a,r)=>({row:a,amount:r,commit:e.makeCommit(t,a,r)});e.start=e=>({board:e,currentPlayer:0,players:[[],[]]}),e.options=e=>e.board.flatMap(((a,r)=>{const n=[];return a.length>1&&n.push(t(e,r,2)),a.length>0&&n.push(t(e,r,1)),n}));e.scores=e=>e.players.map((e=>{return e.reduce((t=e=>e.score,(e,a)=>e+t(a)),0);var t}))}(e||(e={})),function(t){t.optimal=(e=20)=>t=>r(t,0===t.currentPlayer,e).option??null;const a=t=>{const a=e.scores(t);return a[0]-a[1]},r=(t,n,o,u=0,c=-1/0,s=1/0)=>{const l=e.options(t);if(u>=o||0===l.length)return{score:a(t)};let i={score:n?-1/0:1/0};for(let e of l){const t=r(e.commit(),!n,o,u+1,c,s);if(t.option=e,n?(i=i.score>t.score?i:t,c=Math.max(c,i.score)):(i=i.score<t.score?i:t,s=Math.min(s,i.score)),s<c)break}return i}}(t||(t={})),function(e){var t,a;(t=e.Value||(e.Value={})).Two="2",t.Three="3",t.Four="4",t.Five="5",t.Six="6",t.Seven="7",t.Eight="8",t.Nine="9",t.Ten="10",t.Jack="j",t.Queen="q",t.King="k",t.Ace="a",(a=e.Suit||(e.Suit={})).Diamonds="d",a.Hearts="h",a.Spades="s",a.Clubs="c"}(a||(a={})),function(e){e.createFullDeck=()=>Object.values(a.Value).map((e=>Object.values(a.Suit).map((t=>({value:e,suit:t}))))).flat(),e.removeCard=(e,t)=>{const a=e.find((e=>e.value===t.value&&e.suit===t.suit))??null;return{deck:e.filter((e=>e!==a)),card:a}},e.shuffle=e=>{const t=e.slice();for(let e=t.length-1;e>0;e--){const a=Math.floor(Math.random()*(e+1));[t[e],t[a]]=[t[a],t[e]]}return t}}(r||(r={})),function(e){e.TERMINAL_CARD={value:a.Value.Queen,suit:a.Suit.Diamonds},e.create=(t,a=[4,5,5,5],n=e.standardScoring)=>{const{deck:o,card:u}=r.removeCard(t,e.TERMINAL_CARD);if(null==u)throw`ERROR creating board: ${e.TERMINAL_CARD.value} of ${e.TERMINAL_CARD.suit} must be in the deck`;let c=0;const s=a.map((e=>(c+=e,o.slice(c-e,c))));return s[s.length-1]=[u].concat(s[s.length-1]).slice(0,a[a.length-1]),s.map((e=>e.map((e=>({card:e,score:n(e)})))))},e.standardScoring=t=>{if(t.value===e.TERMINAL_CARD.value&&t.suit===e.TERMINAL_CARD.suit)return-10;switch(t.value){case a.Value.Jack:case a.Value.Queen:case a.Value.King:return 10;case a.Value.Ace:return 11;default:return Number(t.value)}}}(n||(n={})),onmessage=e=>{const a=t.optimal(e.data.depth)(e.data.game);postMessage({row:a.row,amount:a.amount})};
